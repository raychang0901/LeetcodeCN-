# 一些排序法的實作細節
### 動機&前提
仔細觀察這些經典演算法的實現，發現其中有很多關於數組的操作是可以學習的，將可應用在刷題時數組類型的題目，讓處理數組時更加地優雅，也同時複習這些演算法的實作。
將注重一些實作的細節，以及這些細節的衍伸題目(LeetCode)，不贅述演算法原理及效率討論，實現語言皆用C++
#### 目錄
- bubble sort
- insertion sort
- merge sort
- quick sort
- heap sort

### Bubble Sort
原理：不斷比較相鄰兩元素大小，每次循環可使最大的元素排出。
思考&衍伸：這個實現其實沒有什麼好思考或衍伸的..但還是把泡沫排序寫出來好了。
```cpp
void bubble_sort(vector<int>& arr){
    int N = arr.size();
    for(int i = 0; i<N; ++i){
        for(int j = N-2; j>=0; --j){
            if(arr[j+1]<arr[j]){ //比較兩相鄰元素
                swap(arr[j+1], arr[j]); //交換
            }
        }
    }
}
```

### Insertion Sort
原理：藉由不斷插入已排序數組來達到整個數組排序。
#### 思考&衍伸：
1.  插入已排序數組時，一般先線性遍歷找到適當的插入位置(要使數組有序)，找到前不斷將數組右移(為了使數插入)
2.  但插入排序有在遍歷到索引i時，i-1已經排序了的特性，故可以考慮使用二分搜尋去優化，其效率為O(N*log(N) )
3.  關於二分搜尋的更多細節：
https://coliru.stacked-crooked.com/a/615975e64f41d88d

#### 一般的插入排序

```cpp
void insertion_sort(vector<int>& arr){
    for(int i = 1; i<arr.size(); ++i){
        int curr = arr[i];
        int j;
        for(j = i-1; j>=0; j--){
            if(curr<arr[j])
                arr[j+1] = arr[j]; //右移
            else{
                break;
            }
        }
        arr[j+1] = curr;
    }
}
```
#### 插入排序加入二分搜尋
```cpp
void insertion_sort_bin(vector<int>& arr){
    for(int i = 1; i<arr.size(); ++i){
        int curr = arr[i];
        int f = 0, b = i-1;
        // find
        while(b>=f){
            int mid = (b+f)/2;
            if(arr[mid]>curr){
                b = mid-1;
            }
            else{
                f = mid+1;
            }
        } 
        for(int j = i-1; j<=f; --j){
            arr[j+1] = arr[j]; //右移
        }
        arr[f] = curr;
    }
}
```
#### 運用STL函式
> lower_bound( begin,end,num)從陣列的begin位置到end-1位置二分查詢第一個大於或等於num的數字，找到返回該數字的地址，不存在則返回end。通過返回的地址減去起始地址begin,得到找到數字在陣列中的下標。
[連結](https://www.itread01.com/content/1542363192.html)
```cpp
void insertion_sort_bin(vector<int>& arr){
    for(int i = 1; i<arr.size(); ++i){
        int curr = arr[i];
        int f = lower_bound(arr.begin(),arr.begin()+i, curr)-arr.begin();
        for(int j = i-1; j<=f; --j){
            arr[j+1] = arr[j]; //右移
        }
        arr[f] = curr;
    }
}
```

### Merge Sort
原理：利用將兩有序數組合併只需要線性時間的特性將數組分割，合併
#### 思考&衍伸：
1.  合併有序數組的技巧：
在有序數組後放一個大數(可以解決長度的問題)

```cpp
void merge_sort(vector<int>& arr, int l, int r){
    if(l>=r){
        return;
    }
    int mid = (r+l)/2;
    merge_sort(arr, l, mid);
    merge_sort(arr, mid+1, r);
    
    vector<int> l_arr(arr.begin()+l, arr.begin()+mid+1);
    vector<int> r_arr(arr.begin()+mid+1, arr.begin()+r+1);
    l_arr.insert(l_arr.end(), INT_MAX);
    r_arr.insert(r_arr.end(), INT_MAX);
    int i = 0,j = 0;
    for(int k = l;k<=r; k++){
        if(l_arr[i]<=r_arr[j]){
            arr[k] = l_arr[i];
            i++;
        }
        else{
            arr[k] = r_arr[j];
            j++;
        }
    }
}
```
#### 不反復宣告子陣列的寫法
傳入與arr大小相同的split陣列
```cpp
void merge_sort(vector<int>& arr, vector<int> split, int l, int r){
    if(l>=r){
        return;
    }
    int mid = (r+l)/2;
    merge_sort(arr, split,l, mid);
    merge_sort(arr, split,mid+1, r);
    for(int i = l; i<r+1; ++i){
        split[i] = arr[i];
    }
    int i = l,j = mid+1;
    for(int k = l;k<=r; k++){
        if(i==mid+1){
            arr[k] = split[j++];
        }
        else if(j==r+1){
            arr[k] = split[i++];
        }
        else if(split[j]<split[i]){
            arr[k] = split[j++];
        }
        else{
            arr[k] = split[i++];
        }
    }
}
```
